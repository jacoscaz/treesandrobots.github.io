
Software development principles:
	---
	title: Principled software development
	description: Enter description here
	---
	
	Over the last few years and particularly during the last months of 2019 
	I've felt a growing sense of disenchantment with the world of programming and
	software development. For the first time in my life I've experienced waking up
	in the morning feeling positively _dreadful_ about my day, wondering about what
	exactly it is that is making me feel so discontent with something I used to be
	so passionate about.
	
	A couple of decades ago, Canadian astronaut Chris Hadfield was given the
	following advice by Helene Hadfield, his wife:
	
	> When you have two days in a row where you don't want to go to work, that you
	> just do not want to go to that job, then it's time to go to another job.
	
	While I am not at that point, I quickly realized that I had to do something
	before I let myself inadvertently get there, and that something had to start
	with finding the root of the problem. Ultimately, as in many other cases in
	life, it turned out to be a matter of _meaning_. 
	
	In order for my career as a software developer to have meaning, the software
	I write must have meaning. I define meaningful software as software that is
	both well-written, usable, fast, efficient, lasting, foundational and 
	respectful of its users. Software that aids its users in the pursuit of their
	own goals whilst being as unintrusive as possible and requiring as little care
	as possible. Software that might even bring about positive change at a societal
	level, however big or small.
	
	I find that, over the last few years, my software - both that of which I am a
	user and that which I develop - hasn't quite been meaningful enough to make me
	feel good about it. What follows is a description of why this is and what I can
	do about it.
	
	## Algorithmic content management
	
	In writing about [his decision not to implement any kind of algorithmic content
	management in NetNewsWire][na-1], Brent Simmons argues:
	
	> These kinds of algorithms optimize for engagement, and the quickest path to 
	> engagement is via the drugs outrage and anger — which require, and generate, 
	> bigger and bigger hits. [...] These algorithms — driven by the all-consuming
	> need for engagement in order to sell ads — are part of what’s destroying 
	> western liberal democracy, and my app will not contribute to that.
	
	Having moved to the UK not long before the advent of the Brexit referendum
	and having spent 5 years living there as a EU citizen, I have personally 
	experienced just how much power these algorithms have come to exert over us
	and how detrimental they can be to public discourse and societal cohesion.
	
	In catering to our lowest instincts, algorithms are contributing to our 
	societal problems in such a substantial way that they have themselves become
	a problem that we need to address.
	
	**What am I going to do about this?** 
	1. consume content sorted by time of publication;
	2. do not implement and/or support and/or be a user of algorithmic content 
		management unless focused on positive engagement.
	
	[na-1]: https://inessential.com/2019/07/02/no_algorithms
	
	## Meaning comes from shipping meaningful work
	
	Tinkering with new technologies is a fundamental part of my life and often the
	part of the day that I most look forward to. However, regardless of much fun I
	can have while doing so, tinkering is generally not conductive to shipping solid, 
	reliable, future-proof, meaningful software.
	
	Meaningful, Choose a set of optimally global technologies (or globally optimal?).
	- http://boringtechnology.club
	
	## Software bloat
	
	In his own wonderful [blog post on software disenchantment][dis-1], Nikita 
	Prokopov argues that _where we are today is bullshit_.
	
	> It just seems that nobody is interested in building quality, fast, 
	> efficient, lasting, foundational stuff anymore. 
	
	> We put virtual machines inside Linux, and then we put Docker inside 
	> virtual machines, simply because nobody was able to clean up the mess that 
	> most programs, languages and their environment produce. 
	
	> It’s fine if a program runs at 1% or even 0.01% of the possible 
	> performance. Everybody just seems to be ok with it. 
	
	> Programs can’t work for years without reboots anymore. Why bother if
	> you can always buy your way out of it. Spin another AWS instance. Restart 
	> process. Move fast, don’t fix.
	
	It's hard for me not to agree whole-heartedly, particularly when I just had
	to quit both Docker and Slack as they had somehow managed to cause a spike in
	power consumptinoo that ate through 30% of my batter in minutes with _no active containers and nothing happening
	in the channels_.
	
	Most of the software run by the [Apollo Guidance Computer][abs-1] has been
	[woven into existence][abs-2] by textile workers manually pulling small wires
	through [magnetic cores][abs-3]. The AGC itself was a 15 bit system based on
	a running on a 1.024 MHz CPU.
	
	The MacBook Pro through which I am writing this post runs a a 2.6 GHz, 64 bit 
	CPU with 6 cores and 32 GB of RAM, at least _three orders of magnitude above_
	the computational power of the glorious AGC when looking at the numbers alone.
	
	How can it be, then, that my spreadsheet software has become _less_ responsive
	with every new major release over the last 10 years? How can it be that things
	as simple as corporate messaging applications can consume multiple gigabytes of
	memory?
	
	Expanding on Nikita's argument, I believe that a critical element of this
	downward spiral is an excessive, indiscriminate and careless adoption of
	abstractions with no proof of wheteher such abstractions actually result in
	better products.
	
	We abstract our hardware into virtual machines. We abstract our operative 
	systems into containers. We abstract our resources into APIs. We abstract
	our processes into CI/CD pipelines.
	
	At some point in the last 10 years, we've crossed a line and started 
	abstracting for abstraction's own sake, as if abstraction itself had been the
	goal all along. Complexity for complexity's sake, often encouraged by 
	management and inexperienced developers, the former interested in short-term
	productivity gains and the latter excited about always having something new and
	shiny to tinker with. However, whereas each single abstraction layer might 
	introduce a penalty so insignificant as to be practically undetectable, the 
	combined effects of layers upon layers of abstraction have finally compounded
	to produce abysmal user experiences and absurd levels of resource utilization.
	
	Furthermore, [abstractions are leaky][abs-4] and when they do leak, forcing us
	to look at what is behind them, we need to be ready to recover and capable of 
	doing so within acceptable timeframes. 
	
	As Joel Spolsky wrote in 2002, [leaky abstractions are dragging us down][abs-4].
	
	Principle: operate on first principle, building programs with the least amount
	of abstractions and dependencies. When considering whether to introduce either, 
	evaluate the potential impacts in terms of performance, maintainability, reliability.
	
	[abs-1]: https://en.wikipedia.org/wiki/Apollo_Guidance_Computer
	[abs-2]: https://en.wikipedia.org/wiki/Core_rope_memory
	[abs-3]: http://www.righto.com/2019/07/software-woven-into-wire-core-rope-and.html?m=1
	[abs-4]: https://www.joelonsoftware.com/2002/11/11/the-law-of-leaky-abstractions/
	[abs-5]: https://danluu.com/hardware-unforgiving/
	
	
	
	
	## Technology should be designed to last
	
	> [...] A growing set of libraries and frameworks are making the web more
	> sophisticated but also more complex. First came jquery, then bootstrap, npm, 
	> angular, grunt, webpack, and more. If you are a web developer who is keeping
	> up with the latest, then that's not a problem. But if not [...], will you 
	> keep this up year after year, decade after decade? 
	
	> [...] the disappearance of the public web in favor of mobile and web apps,
	> walled gardens (Facebook pages), just-in-time WebSockets loading, and AMP
	> decreases the proportion of the web on the world wide web, which now seems
	> more like a continental web than a "world wide web".
	
	
	Jeff Huang [suggests seven unconventional guidelines][last-1] that are worth 
	looking into:
	
	> 1. Return to vanilla HTML/CSS
	> 2. Don't minimize that HTML 
	> 3. Prefer one page over several 
	> 4. End all forms of hotlinking 
	> 5. Stick with the 13 web safe fonts +2
	> 6. Obsessively compress your images
	> 7. Eliminate the broken URL risk
	
	[last-1]: https://jeffhuang.com/designed_to_last/
	
	## Software as functional art
	
	Ruber Verborgh brilliantly argues that expressing ideas clearly and elegantly
	
	> For some reason, many programmers seem to think their role is to write code
	> that makes things work. It’s not. Your job is to solve a problem with code 
	> in the most elegant way, such that your solution is easy to adapt, modify and 
	> reuse.
	
	> Don’t pat yourself on the back because you can write complicated code. 
	> It’s likely you’re doing it wrong. **Programming is understanding a problem 
	> well enough to be able to explain it as simple as possible to a machine.**
	> Defending sloppy code by claiming effectiveness is trying to hide what you 
	> don’t understand: the problem.
	
	[art-1]: https://ruben.verborgh.org/blog/2013/02/21/programming-is-an-art/
	
	
	## Technology should aid humans, not control them
	
	
	Uncritical repetition of bad habits literally trains you in being dumber. A work environment that accumulates bad tools becomes a mind dulling quagmire of required rituals.
	http://www.win-vector.com/blog/2011/04/do-your-tools-support-production-or-complexity/
	
	- http://hades.mech.northwestern.edu/images/7/7f/MR.pdf
	
	
	
	
	
	Technology should require the smallest possible amount of attention
	Technology can communicate, but doesn’t need to speak.
	Create ambient awareness through different senses.
	Communicate information without taking the wearer out of their environment or task.
	Technology should inform and create calm
	A person's primary task should not be computing, but being human.
	Give people what they need to solve their problem, and nothing more.
	Technology should make use of the periphery
	A calm technology will move easily from the periphery of our attention, to the center, and back.
	The periphery is informing without overburdening.
	Technology should amplify the best of technology and the best of humanity
	Design for people first.
	Machines shouldn't act like humans.
	Humans shouldn't act like machines.
	Amplify the best part of each.
	Technology can communicate, but doesn’t need to speak
	Does your product need to rely on voice, or can it use a different communication method?
	Consider how your technology communicates status.
	Technology should work even when it fails
	Think about what happens if your technology fails.
	Does it default to a usable state or does it break down completely?
	The right amount of technology is the minimum needed to solve the problem
	What is the minimum amount of technology needed to solve the problem?
	Slim the feature set down so that the product does what it needs to do and no more.
	Technology should respect social norms
	Technology takes time to introduce to humanity.
	What social norms exist that your technology might violate or cause stress on?
	Slowly introduce features so that people have time to get accustomed to the product.
	- https://calmtech.com
	
	
	
	Design software that collaborates with the user. Machine-aided intelligence is the future. Do not design software that treats the user as an object. Respect your user.
	- https://www.theguardian.com/cities/2020/jan/17/the-case-for-cities-where-youre-the-sensor-not-the-thing-being-sensed
	
	SOLID
	The web was designed to make it possible for information – data – to transfer conveniently no matter where you are or what device you are using. Today data is used as a bargaining chip to lock you in. Solid is a standard that describes how to build storage, apps, and identification in such a way that you can conveniently connect and switch without losing data. If you are interested in the standardisation process, contributions are welcome.
Cloud-based IDEs make bad programmers:
	setting up one's own environment is a necessary activitiy as it provides knowledge about a project itself, what can be kept, what can be simplified